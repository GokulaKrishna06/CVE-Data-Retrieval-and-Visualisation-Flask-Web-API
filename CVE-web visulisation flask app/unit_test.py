import unittest
from flask import Flask, redirect, render_template, request, jsonify
import json
import threading
import time

app = Flask(__name__)

# Load the CVE data from the JSON file initially
with open('cve.json') as f:
    cve_data = json.load(f)['vulnerabilities']

# Define a global variable to hold the CVE data
cve_database = {}

# Function to synchronize CVE data into the database
def synchronize_cve_data():
    global cve_database
    while True:
        with open('cve.json') as f:
            new_cve_data = json.load(f)['vulnerabilities']
        
        # Update the database with new CVE data
        updated_cve_data = clean_and_deduplicate_cve_data(new_cve_data)
        cve_database = {cve['cve']['id']: cve for cve in updated_cve_data}
        
        time.sleep(86400)  # Sleep for 24 hours (86400 seconds)

# Start a separate thread for data synchronization
sync_thread = threading.Thread(target=synchronize_cve_data)
sync_thread.daemon = True
sync_thread.start()

# Function to clean and deduplicate CVE data
def clean_and_deduplicate_cve_data(cve_data):
    cleaned_cve_data = []
    seen_cves = set()
    
    for cve in cve_data:
        cve_id = cve['cve']['id']
        # Check for duplicate CVEs
        if cve_id not in seen_cves:
            # Validate and clean data as needed
            # For example, you can remove unwanted fields or perform data type conversions
            # This step can be expanded based on specific data quality requirements
            cleaned_cve_data.append(cve)
            seen_cves.add(cve_id)
    
    return cleaned_cve_data

# Function to paginate data
def paginate_data(data, page, per_page):
    start_index = (page - 1) * per_page
    end_index = start_index + per_page
    return data[start_index:end_index]

@app.route('/cves/list')
def cve_list():
    # Get query parameters
    page = int(request.args.get('page', 1))
    per_page = int(request.args.get('per_page', 10))
    sort_by = request.args.get('sort_by', 'published')

    # Sort CVE data by the specified field
    cve_data_sorted = sorted(cve_database.values(), key=lambda x: x['cve'][sort_by])

    # Perform server-side sorting for dates
    if sort_by in ['published', 'lastModified']:
        cve_data_sorted = sorted(cve_data_sorted, key=lambda x: x['cve'][sort_by], reverse=True)

    # Perform pagination
    cves_paginated = paginate_data(cve_data_sorted, page, per_page)
    total_records = len(cve_data_sorted)
    total_pages = total_records // per_page
    return render_template('scroll.html', cves=cves_paginated, total_records=total_records, per_page=per_page,total_pages=total_pages)

@app.route('/cves/<cve_id>')
def cve_details(cve_id):
    # Find the CVE details by ID
    cve_details = cve_database.get(cve_id)
    if cve_details:
        # Check if 'configurations' data exists
        if 'configurations' in cve_details['cve']:
            # Fetch 'configurations' data
            configurations_data = cve_details['cve']['configurations']
        else:
            configurations_data = None

        return render_template('test1.html', cve=cve_details, configurations=configurations_data)
    else:
        return "CVE not found", 404

@app.route('/')
def index():
    return redirect('/cves/list')

class TestCVEFunctions(unittest.TestCase):
    def test_clean_and_deduplicate_cve_data(self):
        cve_data = [
            {'cve': {'id': 'CVE-2021-1234', 'description': 'Description 1'}},
            {'cve': {'id': 'CVE-2021-1234', 'description': 'Description 2'}},
            {'cve': {'id': 'CVE-2021-5678', 'description': 'Description 3'}}
        ]
        cleaned_data = clean_and_deduplicate_cve_data(cve_data)
        self.assertEqual(len(cleaned_data), 2)
        self.assertEqual(cleaned_data[0]['cve']['id'], 'CVE-2021-1234')
        self.assertEqual(cleaned_data[1]['cve']['id'], 'CVE-2021-5678')

    def test_paginate_data(self):
        data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        paginated_data = paginate_data(data, 2, 3)
        self.assertEqual(paginated_data, [4, 5, 6])

if __name__ == '__main__':
    unittest.main()
